package org.globsframework.core.utils.serialization;

import org.junit.jupiter.api.Test;

import java.math.BigDecimal;
import java.nio.ByteBuffer;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;


/*
generated by IA
 */
public class NByteBufferSerializationInputRefillTest {

    private static class ChunkedProvider implements NByteBufferSerializationInput.NextBuffer {
        private final byte[] all;
        private final int chunkSize;
        private int offset;

        ChunkedProvider(byte[] all, int chunkSize) {
            this.all = all;
            this.chunkSize = chunkSize;
            this.offset = 0;
        }

        ByteBuffer first() {
            int len = Math.min(chunkSize, all.length);
            offset = len;
            return ByteBuffer.wrap(all, 0, len);
        }

        @Override
        public ByteBuffer refill(ByteBuffer prev) {
            if (offset >= all.length) {
                return ByteBuffer.wrap(new byte[0]);
            }
            int len = Math.min(chunkSize, all.length - offset);
            ByteBuffer next = ByteBuffer.wrap(all, offset, len);
            offset += len;
            return next;
        }
    }

    private static byte[] buildBytes(java.util.function.Consumer<ByteBufferSerializationOutput> writer) {
        byte[] buffer = new byte[64 * 1024];
        ByteBufferSerializationOutput out = new ByteBufferSerializationOutput(buffer);
        writer.accept(out);
        return Arrays.copyOf(buffer, out.position());
    }

    private static NByteBufferSerializationInput buildInputWithChunks(byte[] all, int chunkSize) {
        ChunkedProvider provider = new ChunkedProvider(all, chunkSize);
        return new NByteBufferSerializationInput(provider.first(), provider);
    }

    @Test
    public void testRefill_PrimitivesAndNullables() {
        byte[] all = buildBytes(out -> {
            // ints
            out.write(0x01020304); // exact value to check byte order
            out.writeInteger(null);
            out.writeInteger(42);

            // longs
            out.write(0x0102030405060708L);
            out.writeLong(null);
            out.writeLong(Long.MIN_VALUE);

            // doubles
            out.write(Math.PI);
            out.writeDouble(null);
            out.writeDouble(Math.E);

            // booleans and bytes
            out.write(true);
            out.writeBoolean(null);
            out.writeBoolean(false);
            out.writeByte((byte) 0x7F);
        });

        // Use a tiny chunk size to force multiple refills and cross-boundary reads
        NByteBufferSerializationInput in = buildInputWithChunks(all, 3);

        assertEquals(0x01020304, in.readNotNullInt());
        assertNull(in.readInteger());
        assertEquals(42, in.readInteger());

        assertEquals(0x0102030405060708L, in.readNotNullLong());
        assertNull(in.readLong());
        assertEquals(Long.MIN_VALUE, in.readLong());

        assertEquals(Math.PI, in.readNotNullDouble(), 0.0);
        assertNull(in.readDouble());
        assertEquals(Math.E, in.readDouble(), 0.0);

        assertEquals(Boolean.TRUE, in.readBoolean());
        assertNull(in.readBoolean());
        assertEquals(Boolean.FALSE, in.readBoolean());
        assertEquals((byte) 0x7F, in.readByte());
    }

    @Test
    public void testRefill_ArraysAndBytes() {
        int[] ints = new int[257];
        for (int i = 0; i < ints.length; i++) ints[i] = i * 17 - 1000;
        long[] longs = new long[129];
        for (int i = 0; i < longs.length; i++) longs[i] = (long) i * 1234567890123L - 123;
        double[] doubles = new double[193];
        for (int i = 0; i < doubles.length; i++) doubles[i] = Math.sin(i) * i;
        boolean[] bools = new boolean[513];
        for (int i = 0; i < bools.length; i++) bools[i] = (i % 3) == 0;
        byte[] bytes = new byte[4097];
        for (int i = 0; i < bytes.length; i++) bytes[i] = (byte) (i * 31);

        byte[] all = buildBytes(out -> {
            out.write(ints);
            out.write(longs);
            out.write(doubles);
            out.write(bools);
            out.writeBytes(bytes);

            // Also write null variants to read back
            out.write((int[]) null);
            out.write((long[]) null);
            out.write((double[]) null);
            out.write((boolean[]) null);
            out.writeBytes(null);
        });

        NByteBufferSerializationInput in = buildInputWithChunks(all, 7);

        assertArrayEquals(ints, in.readIntArray());
        assertArrayEquals(longs, in.readLongArray());
        assertArrayEquals(doubles, in.readDoubleArray());
        assertArrayEquals(bools, in.readBooleanArray());
        assertArrayEquals(bytes, in.readBytes());

        assertNull(in.readIntArray());
        assertNull(in.readLongArray());
        assertNull(in.readDoubleArray());
        assertNull(in.readBooleanArray());
        assertNull(in.readBytes());
    }

    @Test
    public void testRefill_Utf8StringAndBigDecimal() {
        // Build a long ASCII string to ensure payload spans many chunks
        char[] chars = new char[5000];
        Arrays.fill(chars, 'A');
        String longString = new String(chars);

        BigDecimal big = new BigDecimal("12345678901234567890.0987654321");

        byte[] all = buildBytes(out -> {
            out.writeUtf8String(longString);
            out.write(big);
            out.writeUtf8String(""); // empty string edge case
            out.writeUtf8String(null); // null case
        });

        // Chunk size small enough to split length int and payload across buffers
        NByteBufferSerializationInput in = buildInputWithChunks(all, 5);

        assertEquals(longString, in.readUtf8String());
        assertEquals(big, in.readBigDecimal());
        assertEquals("", in.readUtf8String());
        assertNull(in.readUtf8String());
    }
}
